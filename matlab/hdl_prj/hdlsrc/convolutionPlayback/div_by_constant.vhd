-- -------------------------------------------------------------
-- 
-- File Name: hdl_prj/hdlsrc/convolutionPlayback/div_by_constant.vhd
-- Created: 2024-05-04 23:42:17
-- 
-- Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: div_by_constant
-- Source Path: convolutionPlayback/convolutionPlayback/recordingConvolver/div_by_constant
-- Hierarchy Level: 2
-- Model version: 1.104
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
USE work.convolutionPlayback_pkg.ALL;

ENTITY div_by_constant IS
  PORT( clk                               :   IN    std_logic;
        reset                             :   IN    std_logic;
        enb                               :   IN    std_logic;
        X                                 :   IN    std_logic_vector(15 DOWNTO 0);  -- uint16
        validIn                           :   IN    std_logic;
        Y                                 :   OUT   std_logic_vector(5 DOWNTO 0);  -- ufix6
        validOut                          :   OUT   std_logic
        );
END div_by_constant;


ARCHITECTURE rtl OF div_by_constant IS

  -- Signals
  SIGNAL X_unsigned                       : unsigned(15 DOWNTO 0);  -- uint16
  SIGNAL mulrnd_din_reg0                  : unsigned(15 DOWNTO 0) := to_unsigned(16#0000#, 16);  -- ufix16
  SIGNAL mulrnd_din_reg1                  : unsigned(15 DOWNTO 0) := to_unsigned(16#0000#, 16);  -- ufix16
  SIGNAL mulrnd_q_reg                     : unsigned(33 DOWNTO 0) := to_unsigned(0, 34);  -- ufix34
  SIGNAL mulrnd_xreg_0                    : unsigned(15 DOWNTO 0) := to_unsigned(16#0000#, 16);  -- ufix16
  SIGNAL mulrnd_yreg_0                    : unsigned(33 DOWNTO 0) := to_unsigned(0, 34);  -- ufix34
  SIGNAL mulrnd_mul_reg                   : unsigned(49 DOWNTO 0) := to_unsigned(0, 50);  -- ufix50
  SIGNAL mulrnd_rnd_reg                   : unsigned(5 DOWNTO 0) := to_unsigned(16#00#, 6);  -- ufix6
  SIGNAL mulrnd_din_reg0_next             : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL mulrnd_din_reg1_next             : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL mulrnd_q_reg_next                : unsigned(33 DOWNTO 0);  -- ufix34_En44
  SIGNAL mulrnd_xreg_0_next               : unsigned(15 DOWNTO 0);  -- ufix16
  SIGNAL mulrnd_yreg_0_next               : unsigned(33 DOWNTO 0);  -- ufix34_En44
  SIGNAL mulrnd_mul_reg_next              : unsigned(49 DOWNTO 0);  -- ufix50_En44
  SIGNAL mulrnd_rnd_reg_next              : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL Y_tmp                            : unsigned(5 DOWNTO 0);  -- ufix6
  SIGNAL valid_reg_reg                    : std_logic_vector(4 DOWNTO 0);  -- ufix1 [5]

BEGIN
  X_unsigned <= unsigned(X);

  -- cgireml component
  mulrnd_process : PROCESS (clk)
  BEGIN
    IF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        mulrnd_din_reg0 <= mulrnd_din_reg0_next;
        mulrnd_din_reg1 <= mulrnd_din_reg1_next;
        mulrnd_q_reg <= mulrnd_q_reg_next;
        mulrnd_xreg_0 <= mulrnd_xreg_0_next;
        mulrnd_yreg_0 <= mulrnd_yreg_0_next;
        mulrnd_mul_reg <= mulrnd_mul_reg_next;
        mulrnd_rnd_reg <= mulrnd_rnd_reg_next;
      END IF;
    END IF;
  END PROCESS mulrnd_process;

  mulrnd_output : PROCESS (X_unsigned, mulrnd_din_reg0, mulrnd_din_reg1, mulrnd_mul_reg, mulrnd_q_reg,
       mulrnd_rnd_reg, mulrnd_xreg_0, mulrnd_yreg_0)
  BEGIN
    Y_tmp <= mulrnd_rnd_reg;
    mulrnd_rnd_reg_next <= mulrnd_mul_reg(49 DOWNTO 44);
    mulrnd_mul_reg_next <= mulrnd_xreg_0 * mulrnd_yreg_0;
    mulrnd_xreg_0_next <= mulrnd_din_reg1;
    mulrnd_yreg_0_next <= mulrnd_q_reg;
    mulrnd_din_reg1_next <= mulrnd_din_reg0;
    IF mulrnd_din_reg0 > to_unsigned(16#0000#, 16) THEN 
      mulrnd_q_reg_next <= unsigned'("1000001100010010011011101001011111");
    ELSE 
      mulrnd_q_reg_next <= unsigned'("1000001100010010011011101001011110");
    END IF;
    mulrnd_din_reg0_next <= X_unsigned;
  END PROCESS mulrnd_output;


  Y <= std_logic_vector(Y_tmp);

  valid_reg_process : PROCESS (clk, reset)
  BEGIN
    IF reset = '1' THEN
      valid_reg_reg <= (OTHERS => '0');
    ELSIF clk'EVENT AND clk = '1' THEN
      IF enb = '1' THEN
        valid_reg_reg(0) <= validIn;
        valid_reg_reg(4 DOWNTO 1) <= valid_reg_reg(3 DOWNTO 0);
      END IF;
    END IF;
  END PROCESS valid_reg_process;

  validOut <= valid_reg_reg(4);

END rtl;

